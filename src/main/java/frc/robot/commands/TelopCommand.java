// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import com.fasterxml.jackson.databind.Module.SetupContext;

import edu.wpi.first.math.MathUtil;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.JoyReadWrite;
import frc.robot.JoyStorage;
import frc.robot.Constants.OIConstants;
import frc.robot.subsystems.ClawSubsystem;
import frc.robot.subsystems.DriveSubsystem;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.LiftSubsystem;
import frc.robot.JoyStorage;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class TelopCommand extends CommandBase {

    //private Joystick m_joystickDriver;
    public enum DriveType
    {
        Telop,
        Record,
        Playback
    }
 
    private int executeCount;
    private int m_seconds;
    private DriveType m_driveType;

  
    private final DriveSubsystem m_robotDrive;
    private final LiftSubsystem m_LiftSubsystem;
    private final ClawSubsystem m_ClawSubsystem;
    private final XboxController m_driverController;
    private final XboxController m_manipulatorController;

    private JoyStorage m_joy[];
    private final int m_joyCountmax = 750;
    String m_filename;

    //int seconds and filename only used in record and playback scenarios
    public TelopCommand(DriveType drivetype, int seconds, String filename, DriveSubsystem subsystem, LiftSubsystem liftsub, ClawSubsystem clawsub) {

     m_driverController = new XboxController(OIConstants.kDriverControllerPort);
     m_manipulatorController = new XboxController(OIConstants.KManipulatorControllerPort);
      
        m_robotDrive = subsystem;
        m_LiftSubsystem = liftsub;
        m_ClawSubsystem = clawsub;
        m_seconds = seconds;
        m_driveType = drivetype;
        m_filename = filename;
        addRequirements(m_robotDrive);
        addRequirements(m_LiftSubsystem);
        addRequirements(m_ClawSubsystem);

        SmartDashboard.putNumber("seconds: ", seconds);
        SmartDashboard.putBoolean("is Playback", m_driveType == DriveType.Playback);

        executeCount = 0;

    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
      
        SmartDashboard.putString("DriveCommand init", "In init tryplayback");

      if (m_driveType == DriveType.Playback)
      {
          SmartDashboard.putString("DriveCommand", "In playback");
          //load data from filename
          m_joy = new JoyStorage[m_joyCountmax];
          m_joy = JoyReadWrite.readObject(m_filename);
          SmartDashboard.putString("in playback", m_filename);
         // m_joy[0].leftdriveYstick = .2;
         
      }
      else
      {
          m_joy = new JoyStorage[m_joyCountmax];
      }

      
    
    }



    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {

        double driveLeftYstick;
        double driveLeftXstick;
        double driveRightXstick;

        double manipulatorLeftYstick;
        boolean buttonYHIGH; 
        boolean buttonALOW;
        boolean buttonBMID;
        boolean buttonXRESET;

        boolean bumperRightIntake;
        boolean bumperLeftExpell;

        if ((executeCount >= 750) && (m_driveType != DriveType.Telop))
        {
            return;
        }

        if (m_driveType != DriveType.Playback) {

            driveLeftYstick = m_driverController.getLeftY();
            driveLeftXstick = m_driverController.getLeftX();
            driveRightXstick = m_driverController.getRightX();

            manipulatorLeftYstick = m_manipulatorController.getLeftY();
            buttonYHIGH = m_manipulatorController.getYButton();
            buttonALOW = m_manipulatorController.getAButton();
            buttonBMID = m_manipulatorController.getBButton();
            buttonXRESET = m_manipulatorController.getXButton();

            bumperRightIntake = m_manipulatorController.getRightBumper();
            bumperLeftExpell = m_manipulatorController.getLeftBumper();

            if (m_driveType == DriveType.Record){
               
                m_joy[executeCount] =  new JoyStorage(driveLeftYstick, driveLeftXstick, driveRightXstick, manipulatorLeftYstick, 
                buttonALOW, buttonBMID, buttonYHIGH, buttonXRESET, bumperRightIntake, bumperLeftExpell);

            }

        } 

        else 
        {
            driveLeftYstick = m_joy[executeCount].leftdriveYstick;
            driveLeftXstick = m_joy[executeCount].leftdriveXStick;
            driveRightXstick = m_joy[executeCount].rightdriveXstick;
            manipulatorLeftYstick = m_joy[executeCount].manipulatorLeftYstick;

            buttonALOW = m_joy[executeCount].buttonA;
            buttonBMID = m_joy[executeCount].buttonB;
            buttonYHIGH = m_joy[executeCount].buttonY;
            buttonXRESET = m_joy[executeCount].buttonX;

            bumperLeftExpell = m_joy[executeCount].bumperLeftExpell;
            bumperRightIntake = m_joy[executeCount].bumperRightIntake;


        }

        
        executeCount++;
        
        SmartDashboard.putNumber("executeCount", executeCount);
        SmartDashboard.putNumber("getLeftX", m_driverController.getLeftX());
        SmartDashboard.putNumber("getManipLeftY",manipulatorLeftYstick);

        //Teleop 
        m_robotDrive.drive(
            -MathUtil.applyDeadband(driveLeftYstick, OIConstants.kDriveDeadband),
            -MathUtil.applyDeadband(driveLeftXstick, OIConstants.kDriveDeadband),
            -MathUtil.applyDeadband(driveRightXstick, OIConstants.kDriveDeadband),
            true, false);
        m_robotDrive.periodic(); 

        m_LiftSubsystem.liftDrive(
            manipulatorLeftYstick, 
                buttonYHIGH,
                buttonBMID,
                buttonALOW,
                buttonXRESET);

        m_ClawSubsystem.ClawDrive(bumperRightIntake, bumperLeftExpell);

    
        //Teleop 

        
        if ((m_driveType != DriveType.Telop) && (executeCount >= 750))
        {
            if (m_driveType == DriveType.Record)
            {
            //save to file
              JoyReadWrite.writeObject(m_joy, m_filename);
            }

            m_robotDrive.drive(
                -MathUtil.applyDeadband(0, OIConstants.kDriveDeadband),
                -MathUtil.applyDeadband(0, OIConstants.kDriveDeadband),
                -MathUtil.applyDeadband(0, OIConstants.kDriveDeadband),
                true, false);
             
            
        }       
        
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {


    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
          //executeCount++;
          if ((m_driveType != DriveType.Telop) && (executeCount >= (m_seconds / 0.02)))
          {
            return true;
          }
          else
          {
            return false;
          }
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
