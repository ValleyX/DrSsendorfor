// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
//import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.DriveSubsystem;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class balance extends CommandBase {

    double speed = 0;//makes the speed that you want to set to the motors
    boolean parked = false;//determining if on ramp
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final DriveSubsystem m_driveTrain;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


    public balance(DriveSubsystem subsystem) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_driveTrain = subsystem;
        addRequirements(m_driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
        //m_joystickDriver = new Joystick(0);
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        SmartDashboard.putString("DriveDistance", "initialize");
        speed = 0;
        
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() { 

      if (balanceOnRamp() < 1) //sets the speed to wot it needs to be
        speed = balanceOnRamp();

      else if (balanceOnRamp() >= 1){
        m_driveTrain.setX(); //stops the robot form moving and finishs the code (probably)
        parked = true;
      }
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
      if (parked == true)
        return true;
      else
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }

  public double balanceOnRamp() {//this is a frame for balancing algorithm
   
    //keeps track of the time
   int time = 0;
   double sped;//variable for robotspeed
   double returnSpeed = 0;//is the speed returned to then use
   boolean start = false; //sees if you needed to start balancing yet
   
   if(time <= 20){//keeps running until it's balanced for a set amount of time
   

     if(Math.abs(m_driveTrain.m_gyro.getPitch()) < 0.05 && start == false){// says to keep going until you gotten not flat and need to start balancing
       returnSpeed = 0.7;
     } 
     else{
       start = true;
     }

     sped = Math.abs(m_driveTrain.m_gyro.getPitch()/50.0);//sets the speed relative to the degree it's at
     if(sped < 0.3){//makes sure the motors use enough power to get up
       sped = 0.3;
     } 
   
     if(m_driveTrain.m_gyro.getPitch() > 0.05 && start == true){//if tilted frontside up may need to be switch
       //drive forward
       returnSpeed = sped;
       time = 0; //resets the clock
     } 
     else if(m_driveTrain.m_gyro.getPitch()  < -0.05){//if tilted backside up may need to be switched
       //drive back
       returnSpeed = -sped;
       time = 0; //resets the clock
     }
     else{
        returnSpeed = 0;//stay still
       time ++; //adds to the ticker to keep track of time put in the end of call
     }
   }

   //stop wheels putting them at 45 degrees and ends code; congrats you've balanced
   if(time >= 20){
     returnSpeed = 100; //makes the speed high so that it ends
   }
   return returnSpeed;
 }
}