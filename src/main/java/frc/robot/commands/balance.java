// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.DriveSubsystem;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class balance extends CommandBase {

    double time = 0;
    boolean onRamp = false;//determining if on ramp
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final DriveSubsystem m_driveTrain;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


    public balance(DriveSubsystem subsystem) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_driveTrain = subsystem;
        addRequirements(m_driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
        //m_joystickDriver = new Joystick(0);
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        SmartDashboard.putString("balance", "initialize");
        time = 0;
        
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
    
            time = balanceOnRamp(0);

        
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        if (time >= 20)
          return Math.abs(m_driveTrain.getImu().getPitch()) < 0.05;
        
        else
          return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }

    
    boolean start = false; //sees if you needed to start balancing yet

  public int balanceOnRamp(int time) {//this is a frame for balancing algorithmwill need more things to be added
   
    //keeps track of the time
   double sped;//variable for robotspeed
   SmartDashboard.putNumber("Pitch", m_driveTrain.getImu().getPitch());
   
   if(time <= 20){//keeps running until it's balanced for a set amount of time
   

     if(Math.abs(m_driveTrain.getImu().getPitch()) < 1 && start == false){// says to keep going until you gotten not flat and need to start balancing
       //m_driveTrain.allPower(0.7, 0);
       m_driveTrain.drive(0, 0.5, 0, true, true);
       //m_driveTrain.getDifferentialDrive().tankDrive(.5,.5);
       
       SmartDashboard.putNumber("Speed", 0.2);
     } 
     else{
       start = true;
     }

     sped = Math.abs(m_driveTrain.getImu().getPitch()/10.0);//sets the speed relative to the degree it's at
     if(sped < 0.4){//makes sure the motors use enough power to get up
       sped = 0.4;
     } 
     else if(sped > 0.6)
      sped = 0.6;

     if(m_driveTrain.getImu().getPitch() > 1 && start == true){//if tilted frontside up may need to be switch
       //drive forward
       //m_driveTrain.allPower(sped, 0);
       //m_driveTrain.getDifferentialDrive().tankDrive(-sped,-sped);
       m_driveTrain.drive(0, -sped, 0, false, true);
       time = 0; //resets the clock
       SmartDashboard.putNumber("Speed", -sped);
       start = true;

     } 
     else if(m_driveTrain.getImu().getPitch()  < -1){//if tilted backside up may need to be switched
       //drive back
       //m_driveTrain.allPower(-sped, 0);
      // m_driveTrain.getDifferentialDrive().tankDrive(sped,sped);
       m_driveTrain.drive(0, sped, 0, false, true);
       time = 0; //resets the clock
       SmartDashboard.putNumber("Speed", sped);
       start = true;

     }
     else if(m_driveTrain.getImu().getPitch()  > -1 && m_driveTrain.getImu().getPitch() < 1 && start ==  true){
        //m_driveTrain.allPower(0, 0);//stay still
        sped = 0;
        //m_driveTrain.getDifferentialDrive().tankDrive(0,0);
        m_driveTrain.drive(0, 0, 0, false, true);
        SmartDashboard.putNumber("Speed", 0);
        start = true;

       time ++; //adds to the ticker to keep track of time put in the end of call
     }
   }

   //stop wheels putting them at 45 degrees and ends code; congrats you've balanced
   if(time >= 20){
     //setX();
    // m_driveTrain.getDifferentialDrive().tankDrive(0,0);
     m_driveTrain.drive(0, 0, 0, true, true);
    }
   return time;
 }
}
